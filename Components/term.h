#pragma once

/*************************************************************************************/
//
//			                    Copyright 2022 Max J. Martin
//
//			                    This file is part of Oliver.
//
//      Boost Software License - Version 1.0 - August 17th, 2003
//
//      Permission is hereby granted, free of charge, to any person or organization
//      obtaining a copy of the software and accompanying documentation covered by
//      this license(the "Software") to use, reproduce, display, distribute,
//      execute, and transmit the Software, and to prepare derivative works of the
//      Software, and to permit third - parties to whom the Software is furnished to
//      do so, all subject to the following :
//
//      The copyright notices in the Software and this entire statement, including
//      the above license grant, this restriction and the following disclaimer,
//      must be included in all copies of the Software, in whole or in part, and
//      all derivative works of the Software, unless such copies or derivative
//      works are solely in the form of machine - executable object code generated by
//      a source language processor.
//
//      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//      FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON - INFRINGEMENT.IN NO EVENT
//      SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//      FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//      ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//      DEALINGS IN THE SOFTWARE.
//			
/*************************************************************************************/

#include "node.h"

namespace Olly {

    /********************************************************************************************/
    //
    //                               'term' Class Definition
    //
    //          The term class is implemented using Lisp inspired data nodes.  It
    //          is used to define the data sets as in Lisp.  
    //
    /********************************************************************************************/

    class term {

        var         _term;
        std::size_t _size;

    public:

        term();
        term(var x);

        friend Text           _type_(const term& self);
        friend bool             _is_(const term& self);
        friend double         _comp_(const term& self, const var& other);

        friend void            _str_(Text_Stream& out, const term& self);
        friend void           _repr_(Text_Stream& out, const term& self);

        friend std::size_t    _size_(const term& self);
        friend var            _lead_(const term& self);
        friend var            _join_(const term& self, const var& other);
        friend var            _next_(const term& self);
        friend var         _reverse_(const term& self);
    };

    /********************************************************************************************/
    //
    //                                 'term' Class Implementation
    //
    /********************************************************************************************/

    term::term() : _term(node()), _size(0) {
    }

    term::term(var x) : _term(node(x)), _size(_term.size()) {
    }

    std::string _type_(const term& self) {
        return "term";
    }

    bool _is_(const term& self) {
        return self._size;
    }

    double _comp_(const term& self, const var& other) {

        auto ptr = other.cast<term>();

        if (ptr) {

            if (self._size == ptr->_size) {

                return self._term.comp(ptr->_term);
            }
        }

        return NOT_A_NUMBER;
    }

    void _str_(Text_Stream& out, const term& self) {

        out << "(";

        if (self._term.is()) {

            self._term.str(out);
            out.seekp(-1, out.cur);
        }

        out << ")";
    }

    void _repr_(Text_Stream& out, const term& self) {

        out << "(";

        if (self._term.is()) {

            self._term.repr(out);
            out.seekp(-1, out.cur);
        }

        out << ")";
    }

    std::size_t _size_(const term& self) {
        return self._size;
    }

    var _lead_(const term& self) {
        return self._term.lead();
    }

    var _join_(const term& self, const var& other) {

        if (other.is_nothing()) {
            return self;
        }

        term a{ self };

        a._term = a._term.join(other);
        a._size += 1;

        return a;
    }

    var _next_(const term& self) {

        if (!_is_(self)) {
            return term();
        }

        term a{ self };

        a._term = a._term.next();
        a._size -= 1;

        return a;
    }

    var _reverse_(const term& self) {

        if (self._term.is_nothing()) {
            return self;
        }

        term a;

        a._term = self._term.reverse();
        a._size = self._size;

        return a;
    }
}