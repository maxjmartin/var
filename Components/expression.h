#pragma once

/*************************************************************************************/
//
//			                    Copyright 2022 Max J. Martin
//
//			                    This file is part of Oliver.
//
//      Boost Software License - Version 1.0 - August 17th, 2003
//
//      Permission is hereby granted, free of charge, to any person or organization
//      obtaining a copy of the software and accompanying documentation covered by
//      this license(the "Software") to use, reproduce, display, distribute,
//      execute, and transmit the Software, and to prepare derivative works of the
//      Software, and to permit third - parties to whom the Software is furnished to
//      do so, all subject to the following :
//
//      The copyright notices in the Software and this entire statement, including
//      the above license grant, this restriction and the following disclaimer,
//      must be included in all copies of the Software, in whole or in part, and
//      all derivative works of the Software, unless such copies or derivative
//      works are solely in the form of machine - executable object code generated by
//      a source language processor.
//
//      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//      FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON - INFRINGEMENT.IN NO EVENT
//      SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//      FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//      ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//      DEALINGS IN THE SOFTWARE.
//			
/*************************************************************************************/

#include "term.h"

namespace Olly {

    /********************************************************************************************/
    //
    //                               'expression' Class Definition
    //
    //          The expression class is implemented using Lisp inspired data nodes.  It
    //          is used to define the data sets as in Lisp.  
    //
    /********************************************************************************************/

    class expression {

        var _lead;
        var _last;

        static const std::size_t balance_limit = 2;

    public:

        expression();
        expression(var x);
        template<typename T, typename... Args>
        expression(T x, Args... args);
        virtual ~expression();

        friend Text           _type_(const expression& self);
        friend bool             _is_(const expression& self);
        friend double         _comp_(const expression& self, const var& other);

        friend void            _str_(Text_Stream& out, const expression& self);
        friend void           _repr_(Text_Stream& out, const expression& self);

        friend std::size_t    _size_(const expression& self);
        friend var            _lead_(const expression& self);
        friend var            _last_(const expression& self);
        friend var            _join_(const expression& self, const var& other);
        friend var            _link_(const expression& self, const var& other);
        friend var            _next_(const expression& self);
        friend var            _prev_(const expression& self);
        friend var         _reverse_(const expression& self);

        friend var             _add_(const expression& self, const var& other);

        template<typename... Args>
        void link(const var& other, Args... args);
        void link(const var& other);
        void link();

        void balance();
        void balance(var& a, var& b);
    };

    /********************************************************************************************/
    //
    //                                 'expression' Class Implementation
    //
    /********************************************************************************************/

    expression::expression() : _lead(term()), _last(term()) {
    }

    expression::expression(var x) : _lead(term()), _last(term(x)) {
    }

    template<typename T, typename... Args>
    expression::expression(T x, Args... args) : _lead(term()), _last(term()) {

        link(x);
        link(args...);
    }

    expression::~expression() {
    }

    std::string _type_(const expression& self) {
        return "expression";
    }

    bool _is_(const expression& self) {
        return self._lead.size() || self._last.size();
    }

    double _comp_(const expression& self, const var& other) {

        auto ptr = other.cast<expression>();

        if (ptr) {

            return self._lead == ptr->_lead && self._last == ptr->_last;
        }

        return NOT_A_NUMBER;
    }

    void _str_(Text_Stream& out, const expression& self) {

        if (!_is_(self)) {
            out << "()";
            return;
        }

        out << "(";

        var e(self._lead);

        while (e.is()) {
            e.lead().str(out);

            e = e.next();

            out << " ";
        }

        e = self._last.reverse();

        while (e.is()) {
            e.lead().str(out);

            e = e.next();

            out << " ";
        }

        out.seekp(-1, out.cur);

        out << ")";
    }

    void _repr_(Text_Stream& out, const expression& self) {

        if (!_is_(self)) {
            out << "()";
            return;
        }

        out << "(";

        var e(self._lead);

        while (e.is()) {
            e.lead().repr(out);

            e = e.next();

            out << " ";
        }

        e = self._last.reverse();

        while (e.is()) {
            e.lead().repr(out);

            e = e.next();

            out << " ";
        }

        out.seekp(-1, out.cur);

        out << ")";
    }

    std::size_t _size_(const expression& self) {
        return self._lead.size() + self._last.size();
    }

    var _lead_(const expression& self) {

        if (self._lead.is()) {
            return self._lead.lead();
        }

        return self._last.reverse().lead();
    }

    var _last_(const expression& self) {

        if (self._last.is()) {
            return self._last.lead();
        }

        return self._lead.reverse().lead();
    }

    var _join_(const expression& self, const var& other) {

        if (other.is_nothing()) {
            return self;
        }

        expression a{ self };

        if (!a._last.is()) {

            a._last = a._last.join(other);
        }
        else {
            a._lead = a._lead.join(other);
        }

        a.balance();

        return a;
    }

    var _link_(const expression& self, const var& other) {

        if (other.is_nothing()) {
            return self;
        }

        expression a{ self };

        if (!a._lead.is()) {

            a._lead = a._lead.join(other);
        }
        else {
            a.link(other);
        }

        return a;
    }

    var _next_(const expression& self) {

        if (!_is_(self)) {
            return expression();
        }

        expression a{ self };

        a.balance();

        if (!a._lead.is()) {

            a._lead = a._lead.join(pop_lead(a._last));
        }

        a._lead = a._lead.next();

        return a;
    }

    var _prev_(const expression& self) {

        if (!_is_(self)) {
            return expression();
        }

        expression a{ self };

        a.balance();

        if (!a._last.is()) {

            a._last = a._last.join(pop_lead(a._lead));
        }

        a._last = a._last.next();

        return a;
    }

    var _reverse_(const expression& self) {

        expression a{ self };

        std::swap(a._lead, a._last);

        return a;
    }

    var _add_(const expression& self, const var& other) {

        auto ptr = other.cast<expression>();

        if (ptr) {

            var a{ self };
            var b{ *ptr };

            while (b.is()) {

                a = a.link(pop_lead(b));
            }

            return a;
        }

        return nothing();
    }

    template<typename ...Args>
    void expression::link(const var& other, Args... args) {

        link(other);

        link(args...);
    }

    void expression::link(const var& other) {

        _last = _last.join(other);

        balance();
    }

    void expression::link() {
    }

    void expression::balance() {

        if ((_lead.size() / balance_limit) > _last.size()) {

            balance(_last, _lead);
        }

        else if ((_last.size() / balance_limit) > _lead.size()) {

            balance(_lead, _last);
        }
    }

    void expression::balance(var& a, var& b) {

        std::vector<var> buffer;

        auto limit = (b.size() / balance_limit);

        while (limit--) {

            buffer.push_back(pop_lead(b));
        }

        var t = a.reverse();

        a = b.reverse();
        b = term();

        for (auto i = buffer.crbegin(); i != buffer.crend(); ++i) {

            b = b.join(*i);
        }

        while (t.is()) {
            a = a.join(pop_lead(t));
        }
    }
}