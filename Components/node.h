#pragma once

/*************************************************************************************/
//
//			                    Copyright 2022 Max J. Martin
//
//			                    This file is part of Oliver.
//
//      Boost Software License - Version 1.0 - August 17th, 2003
//
//      Permission is hereby granted, free of charge, to any person or organization
//      obtaining a copy of the software and accompanying documentation covered by
//      this license(the "Software") to use, reproduce, display, distribute,
//      execute, and transmit the Software, and to prepare derivative works of the
//      Software, and to permit third - parties to whom the Software is furnished to
//      do so, all subject to the following :
//
//      The copyright notices in the Software and this entire statement, including
//      the above license grant, this restriction and the following disclaimer,
//      must be included in all copies of the Software, in whole or in part, and
//      all derivative works of the Software, unless such copies or derivative
//      works are solely in the form of machine - executable object code generated by
//      a source language processor.
//
//      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//      FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON - INFRINGEMENT.IN NO EVENT
//      SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//      FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//      ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//      DEALINGS IN THE SOFTWARE.
//			
/*************************************************************************************/

#include "../var.h"

namespace Olly {

    /********************************************************************************************/
    //
    //                               'node' Class Definition
    //
    //          The node class is implemented using Lisp inspired data nodes.  It
    //          is used to define the data sets as in Lisp.  
    //
    /********************************************************************************************/

    class node {

        var _data;
        var _next;

    public:

        node();
        node(var obj);

        friend Text          _type_(const node& self);
        friend bool            _is_(const node& self);
        friend double        _comp_(const node& self, const var& other);

        friend void            _str_(Text_Stream& out, const node& self);
        friend void           _repr_(Text_Stream& out, const node& self);

        friend std::size_t    _size_(const node& self);
        friend var            _lead_(const node& self);
        friend var            _join_(const node& self, const var& other);
        friend var            _next_(const node& self);
        friend var         _reverse_(const node& self);
    };

    /********************************************************************************************/
    //
    //                                 'node' Class Implementation
    //
    /********************************************************************************************/

    node::node() : _data(), _next() {
    }

    node::node(var object) : _data(object), _next() {
    }

    std::string _type_(const node& self) {
        return "node";
    }

    bool _is_(const node& self) {
        return self._data.is_something();
    }

    double _comp_(const node& self, const var& other) {

        auto ptr = other.cast<node>();

        if (ptr) {

            var a = self;
            var b = *ptr;

            while (a.is() && b.is()) {

                if (a.lead() != b.lead()) {
                    return NOT_A_NUMBER;
                }

                a = a.next();
                b = b.next();
            }

            if (!a.is() && !b.is()) {
                return 0.0;
            }
        }

        return NOT_A_NUMBER;
    }

    void _str_(Text_Stream& out, const node& self) {

        if (!_is_(self)) {
            return;
        }

        var e(self);

        while (e.is()) {
            e.lead().str(out);

            e = e.next();

            out << " ";
        }
    }

    void _repr_(Text_Stream& out, const node& self) {

        if (!_is_(self)) {
            return;
        }

        var e(self);

        while (e.is()) {
            e.lead().repr(out);

            e = e.next();

            out << " ";
        }
    }

    std::size_t _size_(const node& self) {

        if (!_is_(self)) {
            return 0;
        }

        std::size_t size = 1;

        var next = self._next;

        while (next.is()) {

            size += 1;

            next = next.next();
        }

        return size;
    }

    var _lead_(const node& self) {
        return self._data;
    }

    var _join_(const node& self, const var& other) {

        if (other.is_nothing()) {
            return self;
        }

        node a(other);

        if (_is_(self)) {

            a._next = self;
        }

        return a;
    }

    var _next_(const node& self) {

        if (self._next.is_nothing()) {
            return node();
        }

        return self._next;
    }

    var _reverse_(const node& self) {

        if (self._next.is_nothing()) {
            return self;
        }

        var a = node();

        var next = self;

        while (next.is()) {

            a = a.join(next.lead());

            next = next.next();
        }

        return a;
    }
}